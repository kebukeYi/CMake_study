#include <iostream>
#include "virtualFunc.h"

int main() {
    Devid *dp = new Devid;
    // dp->DoSomething(); // 子类执行DoSomething...
    delete dp; // 1,调用子类析构函数  2,调用父类析构函数
    cout << "--------------------------------" << endl;
    Base *b = new Devid;
    // b->DoSomething(); // 父类执行DoSomething....
    delete b; // 1,仅仅调用了调用父类析构函数, 想要继续调用父类析构函数怎么办?
    // 首先需要知道的是, 父类的析构函数在编译时就添加到子类的析构函数中了, 所以只要调用到子类的析构函数,同时也就会调用父类的析构函数;
    // 问题: 多态下,父类指针指向子类对象; delete base; 程序仅仅调用的是 base 的析构函数,因为父类的析构函数不是虚函数,
    // 只是是一个普通函数,不会发生动态绑定，而是静态绑定, 指针的静态类型为基类指针, 因此在delete的时候只会调用父类的析构函数，而不会调用子类的析构函数;

    // 解决: 多态下,父类析构函数设置为 虚函数; 父类指针指向子类对象; delete base; 程序调用 base 的析构函数时,发现其是虚函数,
    // 那么程序就采用动态编译, 就得按照实际传递过来的子类实例, 调用子类的虚函数表,从表中获得真正的子类的析构函数地址;
    // 又因为子类的析构函数在编译时添加了父类的析构函数, 因此在多态下,删除父类指针时,父类和子类的 析构函数都会执行;
    return 0;
}
